From fa4ccd25bab2c5ddebbc3bffe6950837be33aa65 Mon Sep 17 00:00:00 2001
From: Christian Geddes <crgeddes@us.ibm.com>
Date: Fri, 13 Oct 2017 17:15:48 -0500
Subject: [PATCH v1 1007/1007] Re-apply p9_int_scom inits on shutdown path

The interrupt resource provider shutdown path is clearing out some
scom inits that need to be set or else we see problems in the
hypervisor. This commit registers a new event to the shutdown
command which will re-apply the scominits prior to shutting down
and passing off control to the hypervisor

Change-Id: I98e3de847a48447ff592dc3506605e124cdeda4c
---
 src/include/usr/initservice/initserviceif.H      |  22 +--
 src/usr/fapi2/fapi2.mk                           |   7 +
 src/usr/isteps/istep10/makefile                  |   3 +-
 src/usr/isteps/istep21/call_host_start_payload.C | 232 ++++++++++++++++-------
 src/usr/isteps/istep21/makefile                  |   3 +-
 5 files changed, 183 insertions(+), 84 deletions(-)

diff --git a/src/include/usr/initservice/initserviceif.H b/src/include/usr/initservice/initserviceif.H
index d469167..8251bdb 100644
--- a/src/include/usr/initservice/initserviceif.H
+++ b/src/include/usr/initservice/initserviceif.H
@@ -58,18 +58,18 @@ namespace INITSERVICE
      */
     enum EventPriority_t
     {
-        NOTIFY_FIRST     = 0,
-        HIGHEST_PRIORITY = NOTIFY_FIRST,
-        NO_PRIORITY      = 16,
-        MBOX_PRIORITY    = 17,
-        INTR_PRIORITY    = 18,
-        LOWEST_PRIORITY  = 127,
-        CONSOLE_PRIORITY  = LOWEST_PRIORITY,
-        LAST_PRE_MEM_FLUSH_PRIORITY = LOWEST_PRIORITY,
-
+        NOTIFY_FIRST                    = 0,
+        HIGHEST_PRIORITY                = NOTIFY_FIRST,
+        NO_PRIORITY                     = 16,
+        MBOX_PRIORITY                   = 17,
+        INTR_PRIORITY                   = 18,
+        PRESHUTDOWN_INIT_PRIORITY       = 19,
+        LOWEST_PRIORITY                 = 127,
+        CONSOLE_PRIORITY                = LOWEST_PRIORITY,
+        LAST_PRE_MEM_FLUSH_PRIORITY     = LOWEST_PRIORITY,
         HIGHEST_POST_MEM_FLUSH_PRIORITY = 128,  // 1st post mem flush callback
-        PNOR_RP_PRIORITY = HIGHEST_POST_MEM_FLUSH_PRIORITY,
-        POST_MEM_FLUSH_NOTIFY_LAST = 255
+        PNOR_RP_PRIORITY                = HIGHEST_POST_MEM_FLUSH_PRIORITY,
+        POST_MEM_FLUSH_NOTIFY_LAST      = 255
 
     };
 
diff --git a/src/usr/fapi2/fapi2.mk b/src/usr/fapi2/fapi2.mk
index ee1cdc1..6e4b649 100755
--- a/src/usr/fapi2/fapi2.mk
+++ b/src/usr/fapi2/fapi2.mk
@@ -45,6 +45,7 @@ EXTRAINCDIR += $(ROOTPATH)/src/import/chips/p9/procedures/hwp/sbe/
 EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/accessors/
 EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/lib/
 EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/ffdc/
+EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/initfiles/
 EXTRAINCDIR += ${HWP_PATH}
 EXTRAINCDIR += ${HWP_PATH_2}/hwp/memory
 EXTRAINCDIR += ${HWP_PATH_2}/hwp/memory/lib/
@@ -152,9 +153,15 @@ include $(ROOTPATH)/src/import/chips/p9/procedures/hwp/pm/p9_pm_get_poundv_bucke
 include $(ROOTPATH)/src/import/chips/p9/procedures/hwp/pm/p9_pm_get_poundw_bucket.mk
 include $(ROOTPATH)/src/import/chips/p9/procedures/hwp/pm/p9_pm_get_poundw_bucket_attr.mk
 
+# We specifically removed this from the istep10.so and placed it here because
+# we have to reapply this init on the shutdown path after the interrupt resource
+# provider is shutdown
+include $(ROOTPATH)/src/import/chips/p9/procedures/hwp/initfiles/p9_int_scom.mk
+
 VPATH += ${HWP_PATH_1}/hwp/accessors
 VPATH += ${ROOTPATH}/src/import/hwpf/fapi2/src/
 VPATH += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/pm/
 VPATH += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/ffdc/
 VPATH += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/lib/
+VPATH += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/initfiles/
 VPATH += ${GENPATH}
diff --git a/src/usr/isteps/istep10/makefile b/src/usr/isteps/istep10/makefile
index 11f30ef..1c4d7b6 100644
--- a/src/usr/isteps/istep10/makefile
+++ b/src/usr/isteps/istep10/makefile
@@ -84,11 +84,12 @@ include ${PROCEDURES_PATH}/hwp/initfiles/p9_fbc_ioo_dl_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9_nx_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9_cxa_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9_mmu_scom.mk
-include ${PROCEDURES_PATH}/hwp/initfiles/p9_int_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9_vas_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9c_dmi_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9c_mi_scom.mk
 include ${PROCEDURES_PATH}/hwp/initfiles/p9c_mc_scom.mk
+# Note that p9_int_scom.mk is included in fapi2.mk for
+# workaround reasons so we are not including it here
 
 # proc_obus_scominit : Apply scom inits to Obus
 include ${PROCEDURES_PATH}/hwp/io/p9_io_obus_scominit.mk
diff --git a/src/usr/isteps/istep21/call_host_start_payload.C b/src/usr/isteps/istep21/call_host_start_payload.C
index 661af9d..5354ceb 100644
--- a/src/usr/isteps/istep21/call_host_start_payload.C
+++ b/src/usr/isteps/istep21/call_host_start_payload.C
@@ -52,6 +52,8 @@
 #include <p9_cpu_special_wakeup.H>
 #include <ipmi/ipmiwatchdog.H>
 #include <config.h>
+#include <errno.h>
+#include <p9_int_scom.H>
 
 #ifdef CONFIG_DRTM_TRIGGERING
 #include <secureboot/drtm.H>
@@ -74,7 +76,7 @@ namespace ISTEP_21
  * @param[in] Host boot master instance number (logical node number)
  * @param[in] Is this the master HB instance [true|false]
  *
- * @return errlHndl_t - NULL if succesful, otherwise a pointer to the error
+ * @return errlHndl_t - nullptr if succesful, otherwise a pointer to the error
  *      log.
  */
 errlHndl_t callShutdown ( uint64_t i_hbInstance, bool i_masterIntance );
@@ -83,7 +85,7 @@ errlHndl_t callShutdown ( uint64_t i_hbInstance, bool i_masterIntance );
  * @brief This function will send an IPC message to all other HB instances
  *        to perfrom the shutdown sequence.
  * @param[in] Hostboot master instance number (logical node number)
- * @Return errlHndlt_t - Null if succesful, otherwise an error Handle
+ * @Return errlHndlt_t - nullptr if succesful, otherwise an error Handle
  */
 errlHndl_t broadcastShutdown ( uint64_t i_hbInstance );
 
@@ -106,7 +108,7 @@ errlHndl_t enableCoreCheckstops();
  * @brief This function will clear the PORE BARs.  Needs to be done
  *      depending on payload type
  *
- * @return errlHndl_t - NULL if successful, otherwise a pointer to the error
+ * @return errlHndl_t - nullptr if successful, otherwise a pointer to the error
  *      log.
  */
 errlHndl_t clearPoreBars ( void );
@@ -119,90 +121,176 @@ errlHndl_t clearPoreBars ( void );
  *
  * @param[in] i_spFuncs - The SpFuncs system attribute.
  *
- * @return errlHndl_t - NULL if successful, otherwise a pointer to the error
+ * @return errlHndl_t - nullptr if successful, otherwise a pointer to the error
  *      log.
  */
 errlHndl_t notifyFsp ( bool i_istepModeFlag,
                        TARGETING::SpFunctions i_spFuncs );
 
+enum msg_preshutdown_types_t
+{
+    MSG_PRE_SHUTDOWN_INITS = 1 //Tells the msgQ to run inits that
+                               //are needed before shutdown
+};
+
+msg_q_t     msgQ;        //!< Kernel Interrupt message queue
+
+
+void msgHandler()
+{
+    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace, ENTER_MRK"call_host_start_payload::msgHandler()");
+
+    while(1)
+    {
+        msg_t* msg = msg_wait(msgQ); // wait for interrupt msg
+
+        switch(msg->type)
+        {
+            case MSG_PRE_SHUTDOWN_INITS:
+            {
+                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,"Pre-Shutdown Inits event received");
+                errlHndl_t l_errl = NULL;
+                TARGETING::TargetHandleList l_cpuTargetList;
+                getAllChips(l_cpuTargetList, TYPE_PROC);
+                fapi2::Target<fapi2::TARGET_TYPE_SYSTEM> FAPI_SYSTEM;
+
+                for (const auto & l_cpu_target: l_cpuTargetList)
+                {
+                    fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP> l_fapi2_proc_target(l_cpu_target);
+                    FAPI_INVOKE_HWP( l_errl,
+                                     p9_int_scom,
+                                     l_cpu_target,
+                                     FAPI_SYSTEM);
+                    if(l_errl)
+                    {
+                        l_errl->collectTrace("ISTEPS_TRACE",256);
+                        errlCommit(l_errl, ISTEP_COMP_ID );
+                    }
+                }
+
+                msg_respond(msgQ, msg);
+            }
+            break;
+            default:
+                msg->data[1] = -EINVAL;
+                msg_respond(msgQ, msg);
+        }
+    }
+}
+
+
+/**
+* Helper function to start the messge handler
+*/
+void* msg_handler(void * unused)
+{
+    msgHandler();
+    return NULL;
+}
+
 
 void* call_host_start_payload (void *io_pArgs)
 {
-    errlHndl_t  l_errl  =   NULL;
+    errlHndl_t  l_errl  =   nullptr;
 
     IStepError l_StepError;
+    const char* STARTPAYLOAD_MSG_Q = "startpayloadq";
 
     TRACDCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
             "call_host_start_payload entry" );
 
-    // Place a separator in the TPM to indicate we are passing control
-    //  to the next level of firmware in the stack
-    l_errl = TRUSTEDBOOT::pcrExtendSeparator();
+    do{
+
+        // Place a separator in the TPM to indicate we are passing control
+        //  to the next level of firmware in the stack
+        l_errl = TRUSTEDBOOT::pcrExtendSeparator();
+
+        if(l_errl)
+        {
+            break;
+        }
+
+        msgQ = msg_q_create();
 
-    // For single-node systems, the non-master processors can be in a
-    // different logical (powerbus) group.  Need to migrate task to master.
-    task_affinity_pin();
-    task_affinity_migrate_to_master();
+        // Create the kernel msg queue for external interrupts
+        int rc = msg_q_register(msgQ, STARTPAYLOAD_MSG_Q);
+        assert(rc == 0, "Bug! Unable to register message queue");
 
-    uint64_t this_node = PIR_t(task_getcpuid()).groupId;
+        // Register event to be called on shutdown
+        INITSERVICE::registerShutdownEvent(msgQ,
+                                           MSG_PRE_SHUTDOWN_INITS,
+                                           INITSERVICE::PRESHUTDOWN_INIT_PRIORITY);
 
-    task_affinity_unpin();
+        // Create a task to handle the messages
+        task_create(ISTEP_21::msg_handler, NULL);
+
+        // For single-node systems, the non-master processors can be in a
+        // different logical (powerbus) group.  Need to migrate task to master.
+        task_affinity_pin();
+        task_affinity_migrate_to_master();
+
+        uint64_t this_node = PIR_t(task_getcpuid()).groupId;
+
+        task_affinity_unpin();
 
 #ifdef CONFIG_BMC_IPMI
 
-    // TODO ISSUE 118082
-    // ENABLE CODE BELOW ONCE OPAL COMPLETES ipmi WATCHDOG
+        // TODO ISSUE 118082
+        // ENABLE CODE BELOW ONCE OPAL COMPLETES ipmi WATCHDOG
 #if 0
-            //run the ipmi watchdog for a longer period to transition
-            // to opel
-            errlHndl_t err_ipmi = IPMIWATCHDOG::setWatchDogTimer(
-                    IPMIWATCHDOG::DEFAULT_HB_OPAL_TRANSITION_COUNTDOWN);
+                //run the ipmi watchdog for a longer period to transition
+                // to opel
+                errlHndl_t err_ipmi = IPMIWATCHDOG::setWatchDogTimer(
+                        IPMIWATCHDOG::DEFAULT_HB_OPAL_TRANSITION_COUNTDOWN);
 
-            if(err_ipmi)
-            {
-               TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
-                              "init: ERROR: Set IPMI watchdog Failed");
-                err_ipmi->collectTrace("ISTEPS_TRACE",256);
-                errlCommit(err_ipmi, ISTEP_COMP_ID );
+                if(err_ipmi)
+                {
+                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                                "init: ERROR: Set IPMI watchdog Failed");
+                    err_ipmi->collectTrace("ISTEPS_TRACE",256);
+                    errlCommit(err_ipmi, ISTEP_COMP_ID );
 
-            }
+                }
 #endif
 
-    // TODO ISSUE 118082
-    // REMOVE CODE BELOW ONCE OPAL COMPLETES IPMI WATCHDOG
-    // THE CODE BELOW STOPS THE IPMI TIMER FROM RUNNING
-    // TO PREVENT IT GETTING TRIGGERED DURING HB_OPAL TRANSITION
-
-    // Call setWatchdogTimer without the default DON'T STOP
-    // flag to stop the watchdog timer
-    errlHndl_t err_ipmi = IPMIWATCHDOG::setWatchDogTimer(
-            IPMIWATCHDOG::DEFAULT_HB_OPAL_TRANSITION_COUNTDOWN,
-            IPMIWATCHDOG::BIOS_FRB2);
+        // TODO ISSUE 118082
+        // REMOVE CODE BELOW ONCE OPAL COMPLETES IPMI WATCHDOG
+        // THE CODE BELOW STOPS THE IPMI TIMER FROM RUNNING
+        // TO PREVENT IT GETTING TRIGGERED DURING HB_OPAL TRANSITION
 
-    if(err_ipmi)
-    {
-       TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
-                      "init: ERROR: Set IPMI watchdog Failed");
-        err_ipmi->collectTrace("ISTEPS_TRACE",256);
-        errlCommit(err_ipmi, ISTEP_COMP_ID );
+        // Call setWatchdogTimer without the default DON'T STOP
+        // flag to stop the watchdog timer
+        errlHndl_t err_ipmi = IPMIWATCHDOG::setWatchDogTimer(
+                IPMIWATCHDOG::DEFAULT_HB_OPAL_TRANSITION_COUNTDOWN,
+                IPMIWATCHDOG::BIOS_FRB2);
 
-    }
+        if(err_ipmi)
+        {
+            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                            "init: ERROR: Set IPMI watchdog Failed");
+                err_ipmi->collectTrace("ISTEPS_TRACE",256);
+                errlCommit(err_ipmi, ISTEP_COMP_ID );
+        }
 
 #endif
 
-    // broadcast shutdown to other HB instances.
-    l_errl = broadcastShutdown(this_node);
+        // broadcast shutdown to other HB instances.
+        l_errl = broadcastShutdown(this_node);
 
-    if( l_errl == NULL)
-    {
+        if(l_errl)
+        {
+            break;
+        }
         //  - Run CXX testcases
         l_errl = INITSERVICE::executeUnitTests();
-    }
 
-#ifdef CONFIG_DRTM_TRIGGERING
+        if(l_errl)
+        {
+            break;
+        }
 
-    if(l_errl == nullptr)
-    {
+
+#ifdef CONFIG_DRTM_TRIGGERING
         bool drtmMpipl = false;
         SECUREBOOT::DRTM::isDrtmMpipl(drtmMpipl);
         if(!drtmMpipl)
@@ -226,27 +314,29 @@ void* call_host_start_payload (void *io_pArgs)
                     TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace, ERR_MRK
                         "call_host_start_payload: Failed in call to "
                         "initiateDrtm()");
+                    break;
                 }
             }
         }
-    }
-
 #endif
 
-    if( l_errl == NULL )
-    {
         l_errl = disableSpecialWakeup();
-    }
+        if(l_errl)
+        {
+            break;
+        }
 
-    if( l_errl == NULL )
-    {
         //  - Call shutdown using payload base, and payload entry.
         //      - base/entry will be from system attributes
         //      - this will start the payload (Phyp)
         // NOTE: this call will not return if successful.
         l_errl = callShutdown(this_node, true);
+        if(l_errl)
+        {
+            break;
+        }
 
-    };
+    }while(0);
 
     if( l_errl )
     {
@@ -274,7 +364,7 @@ void* call_host_start_payload (void *io_pArgs)
 errlHndl_t callShutdown ( uint64_t i_masterInstance,
                           bool i_isMaster)
 {
-    errlHndl_t err = NULL;
+    errlHndl_t err = nullptr;
     uint64_t payloadBase = 0x0;
     uint64_t payloadEntry = 0x0;
     uint64_t payloadData = 0x0;
@@ -319,10 +409,10 @@ errlHndl_t callShutdown ( uint64_t i_masterInstance,
 
         // Get Target Service, and the system target.
         TargetService& tS = targetService();
-        TARGETING::Target* sys = NULL;
+        TARGETING::Target* sys = nullptr;
         (void) tS.getTopLevelTarget( sys );
 
-        if( NULL == sys )
+        if( nullptr == sys )
         {
             // Error getting system target to get payload related values.  We
             // will create an error to be passed back.  This will cause the
@@ -404,10 +494,10 @@ errlHndl_t callShutdown ( uint64_t i_masterInstance,
 
 errlHndl_t broadcastShutdown ( uint64_t i_hbInstance )
 {
-    errlHndl_t err = NULL;
-    TARGETING::Target * sys = NULL;
+    errlHndl_t err = nullptr;
+    TARGETING::Target * sys = nullptr;
     TARGETING::targetService().getTopLevelTarget( sys );
-    assert(sys != NULL);
+    assert(sys != nullptr);
 
     TARGETING::ATTR_HB_EXISTING_IMAGE_type hb_images =
         sys->getAttr<TARGETING::ATTR_HB_EXISTING_IMAGE>();
@@ -503,7 +593,7 @@ errlHndl_t broadcastShutdown ( uint64_t i_hbInstance )
 
 errlHndl_t disableSpecialWakeup()
 {
-    errlHndl_t l_errl = NULL;
+    errlHndl_t l_errl = nullptr;
 
     TargetHandleList l_cores;
     getAllChiplets(l_cores, TYPE_CORE);
@@ -552,7 +642,7 @@ errlHndl_t disableSpecialWakeup()
  */
 errlHndl_t enableCoreCheckstops()
 {
-    errlHndl_t l_errl = NULL;
+    errlHndl_t l_errl = nullptr;
     //@TODO RTC:133848
 #if 0
     void* l_slwPtr = NULL;
@@ -717,12 +807,12 @@ errlHndl_t enableCoreCheckstops()
  * @brief This function will clear the PORE BARs.  Needs to be done
  *      depending on payload type
  *
- * @return errlHndl_t - NULL if successful, otherwise a pointer to the error
+ * @return errlHndl_t - nullptr if successful, otherwise a pointer to the error
  *      log.
  */
 errlHndl_t clearPoreBars ( void )
 {
-    errlHndl_t l_errl = NULL;
+    errlHndl_t l_errl = nullptr;
 
     TRACFCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
                "set PORE bars back to 0" );
@@ -790,7 +880,7 @@ errlHndl_t clearPoreBars ( void )
 errlHndl_t notifyFsp ( bool i_istepModeFlag,
                        TARGETING::SpFunctions i_spFuncs )
 {
-    errlHndl_t err = NULL;
+    errlHndl_t err = nullptr;
 
     TRACDCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
                ENTER_MRK"notifyFsp()" );
diff --git a/src/usr/isteps/istep21/makefile b/src/usr/isteps/istep21/makefile
index eed55ba..3487563 100644
--- a/src/usr/isteps/istep21/makefile
+++ b/src/usr/isteps/istep21/makefile
@@ -5,7 +5,7 @@
 #
 # OpenPOWER HostBoot Project
 #
-# Contributors Listed Below - COPYRIGHT 2015,2016
+# Contributors Listed Below - COPYRIGHT 2015,2017
 # [+] International Business Machines Corp.
 #
 #
@@ -26,6 +26,7 @@ ROOTPATH = ../../../..
 MODULE = istep21
 
 EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/pm/
+EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/initfiles/
 EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/procedures/hwp/ffdc/
 EXTRAINCDIR += ${ROOTPATH}/src/import/chips/p9/utils/imageProcs/
 EXTRAINCDIR += ${ROOTPATH}/src/import/hwpf/fapi2/include/
-- 
1.8.2.2

