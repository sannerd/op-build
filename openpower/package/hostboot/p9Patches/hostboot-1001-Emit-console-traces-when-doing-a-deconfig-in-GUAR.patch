From fb0f71cf036b2d446d9c01968dca20707bc1ca16 Mon Sep 17 00:00:00 2001
From: Dean Sanner <dsanner@us.ibm.com>
Date: Wed, 23 Aug 2017 08:42:41 -0500
Subject: [PATCH v1 1001/1006] Emit console traces when doing a deconfig in
 GUARD

  -- Print out a message on what is being deconfigured
     for easier debug
  -- Also emit the functional procs, cores, and dimms

Change-Id: Ib46b197c80b0007b05cbfa783f985241625135cb
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/45041
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Reviewed-by: Prachi Gupta <pragupta@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/usr/hwas/common/deconfigGard.C             | 14 +++++++++
 src/usr/isteps/istep06/host_discover_targets.C | 11 +++++--
 src/usr/isteps/istep06/host_gard.C             | 42 ++++++++++++++++++++++++++
 3 files changed, 65 insertions(+), 2 deletions(-)

diff --git a/src/usr/hwas/common/deconfigGard.C b/src/usr/hwas/common/deconfigGard.C
index cf6db2a..a781f46 100644
--- a/src/usr/hwas/common/deconfigGard.C
+++ b/src/usr/hwas/common/deconfigGard.C
@@ -42,6 +42,9 @@
 
 #ifdef __HOSTBOOT_MODULE
 #include <config.h>
+#if (!defined(CONFIG_CONSOLE_OUTPUT_TRACE) && defined(CONFIG_CONSOLE))
+#include <console/consoleif.H>
+#endif
 #endif
 
 #ifdef CONFIG_BMC_IPMI
@@ -521,6 +524,11 @@ errlHndl_t DeconfigGard::deconfigureTargetsFromGardRecordsForIpl(
                 }
             }
 
+#if (!defined(CONFIG_CONSOLE_OUTPUT_TRACE) && defined(CONFIG_CONSOLE))
+            CONSOLE::displayf("HWAS", "Deconfig HUID 0x%08X, %s",
+                    get_huid(l_pTarget),
+                    l_pTarget->getAttr<TARGETING::ATTR_PHYS_PATH>().toString());
+#endif
         } // for
 
         if (l_pErr)
@@ -724,6 +732,12 @@ errlHndl_t DeconfigGard::deconfigureTargetsFromGardRecordsForIpl(
                     break;
                 }
             }
+
+#if (!defined(CONFIG_CONSOLE_OUTPUT_TRACE) && defined(CONFIG_CONSOLE))
+            CONSOLE::displayf("HWAS", "Deconfig HUID 0x%08X, %s",
+                    get_huid(l_pTarget),
+                    l_pTarget->getAttr<TARGETING::ATTR_PHYS_PATH>().toString());
+#endif
         } // for
         if(l_pErr)
         {
diff --git a/src/usr/isteps/istep06/host_discover_targets.C b/src/usr/isteps/istep06/host_discover_targets.C
index ccd6863..2e5e742 100644
--- a/src/usr/isteps/istep06/host_discover_targets.C
+++ b/src/usr/isteps/istep06/host_discover_targets.C
@@ -554,8 +554,8 @@ void* host_discover_targets( void *io_pArgs )
             continue;
         }
         TARGETING::TYPE l_type = target->getAttr<TARGETING::ATTR_TYPE>();
-        TARGETING::ATTR_POSITION_type l_pos = 0;
-        if( target->tryGetAttr<TARGETING::ATTR_POSITION>(l_pos) )
+        TARGETING::ATTR_FAPI_POS_type l_pos = 0;
+        if( target->tryGetAttr<TARGETING::ATTR_FAPI_POS>(l_pos) )
         {
             l_presData[l_type] |= (0x8000000000000000 >> l_pos);
         }
@@ -567,6 +567,13 @@ void* host_discover_targets( void *io_pArgs )
     {
         uint8_t l_type = itr->first;
         uint64_t l_val = itr->second;
+        //Only want to display procs, dimms, and cores
+        if((l_type != TARGETING::TYPE_DIMM) &&
+           (l_type != TARGETING::TYPE_PROC) &&
+           (l_type != TARGETING::TYPE_CORE))
+        {
+            continue;
+        }
         TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                 "PRESENT> %s[%.2X]=%.8X%.8X",
                 l_epath.pathElementTypeAsString(itr->first),
diff --git a/src/usr/isteps/istep06/host_gard.C b/src/usr/isteps/istep06/host_gard.C
index ff323f5..f379d0c 100644
--- a/src/usr/isteps/istep06/host_gard.C
+++ b/src/usr/isteps/istep06/host_gard.C
@@ -120,6 +120,48 @@ void* host_gard( void *io_pArgs )
             }
         }
 
+        // Put out some helpful messages that show which targets are usable
+        std::map<TARGETING::TYPE,uint64_t> l_funcData;
+        for (auto target : TARGETING::targetService())
+        {
+            if (!(target->getAttr<TARGETING::ATTR_HWAS_STATE>().functional))
+            {
+                continue;
+            }
+            TARGETING::TYPE l_type =target->getAttr<TARGETING::ATTR_TYPE>();
+            TARGETING::ATTR_FAPI_POS_type l_pos = 0;
+            if( target->tryGetAttr<TARGETING::ATTR_FAPI_POS>(l_pos) )
+            {
+                l_funcData[l_type] |= (0x8000000000000000 >> l_pos);
+            }
+        }
+        TARGETING::EntityPath l_epath;
+        for( auto l_data : l_funcData)
+        {
+            auto l_type = l_data.first;
+            uint64_t l_val = l_data.second;
+            //Only want to display procs, dimms, and cores
+            if((l_type != TARGETING::TYPE_DIMM) &&
+               (l_type != TARGETING::TYPE_PROC) &&
+               (l_type != TARGETING::TYPE_CORE))
+            {
+                continue;
+            }
+            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                      "FUNCTIONAL> %s[%.2X]=%.8X%.8X",
+                      l_epath.pathElementTypeAsString(l_type),
+                      l_type,
+                      l_val>>32, l_val&0xFFFFFFFF);
+
+#if (!defined(CONFIG_CONSOLE_OUTPUT_TRACE) && defined(CONFIG_CONSOLE))
+            CONSOLE::displayf("HWAS", "FUNCTIONAL> %s[%.2X]=%.8X%.8X",
+                              l_epath.pathElementTypeAsString(l_type),
+                              l_type,
+                              l_val>>32,
+                              l_val&0xFFFFFFFF );
+#endif
+            }
+
         //  check and see if we still have enough hardware to continue
         l_err = HWAS::checkMinimumHardware();
         if(l_err)
-- 
1.8.2.2

